---
title: "Section Two -- What is Data?"
author: "Mike Mahoney, April 2020"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [default, hygge, ninjutsu]
    nature:
      ratio: 16:10
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 8, fig.height = 4, message = FALSE, warning = FALSE, comment = "", cache = FALSE, fig.retina = 3)
library(flipbookr)
```

What does this code do?

```{r eval=FALSE}
1 + 1
```

--

```{r echo=FALSE}
1 + 1
```

--

<br>

What about this code?

```r
1 + "hello world"
```

--

`Error in 1 + "hello world" : non-numeric argument to binary operator`

---

`1 + 1` did pretty much exactly what we'd expect -- the `+` sign added the two 
numbers together.

<br>

There's no clear way to add a number and a not-number together, so running 
`1 + "hello world"` errors out -- there's no behavior defined for trying to use
`+` with text.

<br>

This basic idea -- that numbers and not-numbers are different things -- is 
surprisingly important when it comes to computers.


---

```{r vec_classes, include=FALSE}
class(1)

class("hello world")

class(TRUE)

class(FALSE)
```

`r chunk_reveal("vec_classes")`

---

This is why some functions which work well for numeric inputs:

```{r}
sqrt(1)
```

<br>

Work less well for characters:

```r
sqrt("hello world")
```

`Error in sqrt("hello world") : invalid 'type' (character) of argument`

---

Let's talk about logical values for a second.

Much in the same way as R has arithmetic operators, like `+`, `-`, and so on, R 
also has _logical operators_. Instead of doing math, these operators tell you 
whether or not a statement is `TRUE` or `FALSE`:

```{r}
# Statement: 4 is greater than 5.
4 > 5

# Statement: 10 is less than or equal to 10.
10 <= 10

# Statement: 5 is equal to 5.
5 == 5

# Statement: 5 is not equal to 5.
5 != 5
```

---

The two main logical values are `TRUE` and `FALSE`. Internally, R views `TRUE` as
being equal to 1 and `FALSE` as being equal to 0:

<br>

```{r}
TRUE == 1

FALSE == 0
```

---

What will this code do?

```r
sqrt(1, 4)
```

--

`Error in sqrt(1, 4) : 2 arguments passed to 'sqrt' which requires 1`

<br>

We're trying to take the square root of multiple numbers, but `sqrt` only takes 
one argument.

<br>

We need to find a way to provide multiple numbers to a single argument!

---

When you just enter a single value, you create what's known as a _scalar_:

```{r}
1
4
```

<br> 

We can _combine_ those scalars into longer objects called _vectors_, using the 
`c()` function:

```{r}
c(1, 4)
```

<br>

--

```{r eval=FALSE}
sqrt(c(1, 4))
```

--

```{r echo=FALSE}
sqrt(c(1, 4))
```

---

All data in R is stored in a vector -- even a scalar is a vector with just a 
single value.

<br>

Vectors also have classes:

```{r}
class(c(1, 4))

class(c("hello", "world"))

class(c(TRUE, FALSE))
```

---

What class is this vector?

```{r, eval=FALSE}
class(c(1, "hello"))
```

--

```{r, echo=FALSE }
class(c(1, "hello"))
```

```{r}
## The 1 even gets quoted in the output!
c(1, "hello")
```

--

<br> 

**Vectors can only store one type of data.**

```{r}
class(c(TRUE, "hello"))
```

--

```{r}
class(c(1, TRUE))

c(1, FALSE) # FALSE == 0; TRUE == 1
```

---
class: center, middle, inverse, title-slide

```{r, fig.width=10, fig.height=7, echo=FALSE}
knitr::include_graphics("why-care.png")
```

---

But we don't usually only care about one type of data at a time. So what do we 
do when we need to combine different types of data?

<br>

R provides the _data frame_ just for these cases. We can make them with the 
`data.frame` function:

```{r}
data.frame(x = c("one", "two"),
           y = c(9, 8))
```

<br>

Each of our columns is made up of a single vector, made with `c()`. We also 
named each of our columns with `x =` and `y =` -- try changing the names around. 
What does it take to make the function throw an error?

---

Almost all data we'll be dealing with will be in the form of data frames. In 
fact, we've already dealt with data frames -- where?

--

```{r}
head(iris)
```

--

<br>

```{r, fig.width=10, fig.height=7, echo=FALSE}
knitr::include_graphics("tidy.png")
```

---

```{r echo=FALSE}
head(tidyr::pivot_longer(cbind(iris, obs = rep(1:50, 3)), 
                         c("Sepal.Length", 
                           "Sepal.Width", 
                           "Petal.Length", 
                           "Petal.Width"), 
                         names_to = "variable", 
                         values_to = "value"))
```

<br>

--

* The `value` column represents a lot of different things -- possibly with 
  different units and definitions

<br>

* Wrapping your head around an observation is harder -- is the petal width or 
sepal length longer for flower 1? What's the normal range for petal length?

<br>

* Tooling isn't built for it -- how would we even get this into a ggplot?

---

What does this code do?

```r
max(iris)
```

--

`Error in FUN(X[[i]], ...) : only defined on a data frame with all numeric variables`

<br> 

So all of our data is stored inside the data frame -- but to use things like 
`max`, we have to get parts of it back out!

---

We call this _subsetting_ our data frame -- selecting only specific pieces of it.
There's actually a few ways of doing this, and we've seen one before: we can 
use the `$` operator to pull out a column by name:

```{r}
head(iris$Sepal.Length)
```

--

<br>

We can do pretty much the same thing using `[]` to pull out a column by name -- 
note that this time around, we have to quote the name:

```{r}
head(iris["Sepal.Length"])
```

---

We can also pull a column out by position -- so use `1` to pull out the 
first column, `2` for the second, and so on:

```{r}
head(iris[1])
```

--

<br>

What's the difference between these two methods and `$`?

```{r}
head(iris$Sepal.Length)
```


---

You can see that `[]` returns a data frame, while `$` returns a vector. If we 
need to return a vector using brackets, we can use `[[]]`:

```{r}
head(iris[[1]])
```

There are reasons we sometimes need a vector instead of a data frame -- for 
instance, some functions return really weird outputs (or even errors) when given
dataframes instead of vectors:

```{r}
c(0, 0, 0, head(iris[1]))
```

Try it with double brackets to see what's different!

---

There are also good reasons to use `[]` instead of `$`. For instance, we can 
provide two arguments to `[]` in order to select a row and a column, instead of 
just a row:

```{r}
# Select row 15 from the sepal length column:
iris[[15, "Sepal.Length"]]
```

<br>

--

We can also provide vectors as arguments to `[]` to return multiple rows or 
columns:
```{r}
# Select rows 1:6 from the sepal length and species columns
# Note that 1:6 is a shorthand for c(1, 2, 3, 4) -- it generates a 
# sequence between any two integers
iris[1:4, c("Sepal.Length", "Species")]
```

--

<br>

When working with data frames, the order is always `[row, column]`

---
class: center, middle, title

# Exercise 1

---

There's one more common way to subset our data, and that's by using a function 
from the `dplyr` package. 

`dplyr` was also installed when you installed `tidyverse`, so let's just load it
now:

```{r}
library(dplyr)
```

<br>

`dplyr` gives us the `select()` function, which works a little differently. We 
call it like `sqrt()` or `plot()` functions, and pass it our data frame as the 
first argument, then the names of the columns we want to access:

```{r}
head(
  select(iris, Sepal.Length, Sepal.Width) # Note: no quotes!
)
```

---

You'll notice that `select()` returns a data frame, just like `[]`. Actually, 
all `dplyr` functions return (and usually take as inputs) data frames -- that's 
what the `d` in `dplyr` stands for!

--

But `dplyr` provides a lot more than just `select()`. For instance, let's say we
wanted to find all the irises with sepals that are more than 5 cm long.

<br>

We already know how to get R to tell us if each sepal length is longer than 5 cm,
using logical operators:

<br>

```{r, message=FALSE}
head(
  iris$Sepal.Length > 5
)
```

---

We can combine that with the `filter()` function from `dplyr` to return the full
row every time that condition is `TRUE` -- so in this case, each row where 
Sepal.Length is greater than 5:

<br>

```{r}
head(
  # don't need to subset iris, since we provided it as an argument
  filter(iris, Sepal.Length > 5)
)
```

---

Now, what if we wanted to do both of those -- if we wanted to filter our dataset
_and_ select specific columns?

One way we can do things like this is by _nesting functions_ -- that is, 
putting a function entirely inside of another function. For instance, we can 
replace the data argument in `select()` with the entire `filter()` call:

```{r}
head(
  select(
    # We replaced the iris dataset with the filtered one --
    # since it returns a data frame, we can use it as the data 
    # argument to select
    filter(iris, Sepal.Length > 5),
    # The other arguments to select are the same:
    Sepal.Length, 
    Sepal.Width)
)
```

---

We've done this before, when making plots too:

```r
## aes is a function inside a function!
ggplot(<data>, aes(<mapping>))
```

---

This starts to get hard to read, though, particularly once we chain together 
more than two or three steps.

<br>

Luckily, `dplyr` provides another operator to let us write things in a more 
readable manner. The `%>%` operator, known as the _pipe_, lets us write code 
that reads from right to left -- we take the output on the left side of the 
pipe, then use it as the first argument in the function on the right. 

<br>

Personally, I always think of the pipe as a way to say "and then...":

```{r}
iris %>% # Take the iris dataset, and then...
  filter(Sepal.Length > 5) %>% # filter the data, and then...
  select(Sepal.Length, Sepal.Width) %>% # ...select columns, and then...
  head() # ...select the top rows of the data.
```

---

So now we're able to subset our data in all sorts of different ways. That's 
cool, but it would be helpful for us to actually manipulate the data as well!

<br>

`dplyr` comes in handy again here, with a number of functions for manipulating 
data. Chief among these is `mutate`, which we can use to create a new column in 
our data frame:

```{r}
iris %>% 
  mutate(total = Sepal.Length + Sepal.Width + Petal.Length + Petal.Width) %>% 
  head()
```

<br>

Note that `mutate` will do the same thing to each row of your dataset, and will
give you an output that's the same length as the input data frame.

---

We can even combine this with our subsetting functions! 

<br>

See if you can combine `mutate` and `filter` to find the flower with the largest
difference between its sepal length and width.

--

```{r}
iris %>% 
  mutate(sepal_difference = abs(Sepal.Length - Sepal.Width)) %>% 
  filter(sepal_difference == max(sepal_difference))
```

<br>

(What do you think abs() does?)

---
class: center, middle, inverse, title-slide

# Exercise 2

---

This is cool, but what if we wanted to find the flower of each species with the 
largest difference? We might try adding a condition to our `filter` function:

```{r}
iris %>% 
  mutate(sepal_difference = abs(Sepal.Length - Sepal.Width)) %>% 
  filter(Species == "setosa" & # "&" means both conditions need to be TRUE
           sepal_difference == max(sepal_difference))
```

But because there's no single record that is _both_ a "setosa" and has the 
largest difference -- because only one record has the largest difference, and 
it's a virginica.

--

We could try using two filter statements instead: 

```{r}
iris %>% 
  filter(Species == "setosa") %>% 
  mutate(sepal_difference = abs(Sepal.Length - Sepal.Width)) %>% 
  filter(sepal_difference == max(sepal_difference))
```

But that seems silly -- and it would take a lot of typing to do this for each 
species!

---

Luckily, `dplyr` provides functions to make this easier! We can use the 
`group_by` function to _group_ our data frame by a variable.  
Our `filter` function then will calculate the `max(sepal_difference)` separately for each species, so we'll get results for each species in one go:

```{r}
iris %>% 
  mutate(sepal_difference = abs(Sepal.Length - Sepal.Width)) %>% 
  group_by(Species) %>% 
  filter(sepal_difference == max(sepal_difference))
```

<br>

Under the hood, `group_by` is basically splitting our dataframe into three -- 
one per species -- running our code on each of them, and then combining them 
back into a single table at the end. Luckily, `group_by` handles all the work 
for us, so we don't have to think about most of those in-between steps!

---



```{r}
iris %>% 
  group_by(Species) %>% 
  summarise(mean_length = mean(Sepal.Length),
            median_length = median(Sepal.Length))
```

---



---



---

    rename() to select variables based on their names.

    count / tally

    distinct
    
    group_by
    summarise