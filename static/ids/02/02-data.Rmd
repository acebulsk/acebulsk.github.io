---
title: "Section Two -- What is Data?"
author: "Mike Mahoney, April 2020"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: [default, hygge, ninjutsu]
    nature:
      ratio: 16:10
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
    self_contained: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width = 8, fig.height = 4, message = FALSE, warning = FALSE, comment = "", cache = FALSE, fig.retina = 3)
library(flipbookr)
```

What does this code do?

```{r eval=FALSE}
1 + 1
```

--

```{r echo=FALSE}
1 + 1
```

--

<br>

What about this code?

```r
1 + "hello world"
```

--

`Error in 1 + "hello world" : non-numeric argument to binary operator`

---

`1 + 1` did pretty much exactly what we'd expect -- the `+` sign added the two 
numbers together.

<br>

There's no clear way to add a number and a not-number together, so running 
`1 + "hello world"` errors out -- there's no behavior defined for trying to use
`+` with text.

<br>

This basic idea -- that numbers and not-numbers are different things -- is 
surprisingly important when it comes to computers.


---

```{r vec_classes, include=FALSE}
class(1)

class("hello world")

class(TRUE)

class(FALSE)
```

`r chunk_reveal("vec_classes")`

---

This is why some functions which work well for numeric inputs:

```{r}
sqrt(1)
```

<br>

Work less well for characters:

```r
sqrt("hello world")
```

`Error in sqrt("hello world") : invalid 'type' (character) of argument`

---

Let's talk about logical values for a second.

Much in the same way as R has arithmetic operators, like `+`, `-`, and so on, R 
also has _logical operators_. Instead of doing math, these operators tell you 
whether or not a statement is `TRUE` or `FALSE`:

```{r}
# Statement: 4 is greater than 5.
4 > 5

# Statement: 10 is less than or equal to 10.
10 <= 10

# Statement: 5 is equal to 5.
5 == 5

# Statement: 5 is not equal to 5.
5 != 5
```

---

The two main logical values are `TRUE` and `FALSE`. Internally, R views `TRUE` as
being equal to 1 and `FALSE` as being equal to 0:

<br>

```{r}
TRUE == 1

FALSE == 0
```

---

There's one more logical value in R: `NA`, used to represent missing values.

```{r}
class(NA)
```

Because `NA` represents a value that should exist but doesn't, it doesn't 
cooperate with most functions -- almost every function returns `NA` when given
`NA` as an input:

```{r}
NA + 5
```

In fact, NA isn't even equal to `NA` -- because we don't know what value the
missing data _should_ be, we aren't able to tell whether it is or isn't equal
to anything else.

```{r}
NA == NA
```

Instead, we use `is.na` to check whether a value is `NA` or not:

```{r}
is.na(NA)
```

---

What will this code do?

```r
sqrt(1, 4)
```

--

`Error in sqrt(1, 4) : 2 arguments passed to 'sqrt' which requires 1`

<br>

We're trying to take the square root of multiple numbers, but `sqrt` only takes 
one argument.

<br>

We need to find a way to provide multiple numbers to a single argument!

---

When you just enter a single value, you create what's known as a _scalar_:

```{r}
1
4
```

<br> 

We can _combine_ those scalars into longer objects called _vectors_, using the 
`c()` function:

```{r}
c(1, 4)
```

<br>

---

We can then provide vectors to functions which are expecting only a single data 
argument:

```{r eval=FALSE}
sqrt(c(1, 4))
```

--

```{r echo=FALSE}
sqrt(c(1, 4))
```

<br>

Note that functions will usually do one of two different things when you're 
passed a vector. 

Some functions, like `sqrt`, do something to each value in the 
vector separately and then return a vector of the same length; these are called 
_vectorized_ functions.

Some functions, however, will operate on the vector as a whole and return a 
scalar output:

```{r}
sum(c(1, 4))
```


---

All data in R is stored in a vector -- even a scalar is a vector with just a 
single value.

<br>

Vectors also have classes:

```{r}
class(c(1, 4))

class(c("hello", "world"))

class(c(TRUE, FALSE))
```

---

What class is this vector?

```{r, eval=FALSE}
class(c(1, "hello"))
```

--

```{r, echo=FALSE}
class(c(1, "hello"))
```

```{r}
## The 1 even gets quoted in the output!
c(1, "hello")
```

--

<br> 

**Vectors can only store one type of data.**

```{r}
class(c(TRUE, "hello"))
```

--

```{r}
class(c(1, TRUE))

c(1, FALSE) # FALSE == 0; TRUE == 1
```

---
class: center, middle, inverse, title-slide

```{r, fig.width=10, fig.height=7, echo=FALSE}
knitr::include_graphics("why-care.png")
```

---

But we don't usually only care about one type of data at a time. So what do we 
do when we need to combine different types of data?

<br>

R provides the _data frame_ just for these cases. We can make them with the 
`data.frame` function:

```{r}
data.frame(x = c("one", "two"),
           y = c(9, 8))
```

<br>

Each of our columns is made up of a single vector, made with `c()`. We also 
named each of our columns with `x =` and `y =` -- try changing the names around. 
What does it take to make the function throw an error?

---

Almost all data we'll be dealing with will be in the form of data frames. In 
fact, we've already dealt with data frames -- where?

--

```{r}
head(iris)
```

--

<br>

```{r, fig.width=10, fig.height=7, echo=FALSE}
knitr::include_graphics("tidy.png")
```

---

```{r echo=FALSE}
head(tidyr::pivot_longer(cbind(iris, obs = rep(1:50, 3)), 
                         c("Sepal.Length", 
                           "Sepal.Width", 
                           "Petal.Length", 
                           "Petal.Width"), 
                         names_to = "variable", 
                         values_to = "value"))
```

<br>

--

* The `value` column represents a lot of different things -- possibly with 
  different units and definitions

<br>

* Wrapping your head around an observation is harder -- is the petal width or 
sepal length longer for flower 1? What's the normal range for petal length?

<br>

* Tooling isn't built for it -- how would we even get this into a ggplot?

---

What does this code do?

```r
max(iris)
```

--

`Error in FUN(X[[i]], ...) : only defined on a data frame with all numeric variables`

<br> 

So all of our data is stored inside the data frame -- but to use things like 
`max`, we have to get parts of it back out!

---

We call this _subsetting_ our data frame -- selecting only specific pieces of it.
There's actually a few ways of doing this, and we've seen one before: we can 
use the `$` operator to pull out a column by name:

```{r}
head(iris$Sepal.Length)
```

--

<br>

We can do pretty much the same thing using `[]` to pull out a column by name -- 
note that this time around, we have to quote the name:

```{r}
head(iris["Sepal.Length"])
```

---

We can also pull a column out by position -- so use `1` to pull out the 
first column, `2` for the second, and so on:

```{r}
head(iris[1])
```

--

<br>

What's the difference between these two methods and `$`?

```{r}
head(iris$Sepal.Length)
```


---

You can see that `[]` returns a data frame, while `$` returns a vector. If we 
need to return a vector using brackets, we can use `[[]]`:

```{r}
head(iris[[1]])
```

There are reasons we sometimes need a vector instead of a data frame -- for 
instance, some functions return really weird outputs (or even errors) when given
dataframes instead of vectors:

```{r}
c(0, 0, 0, head(iris[1]))
```

Try it with double brackets to see what's different!

---

There are also good reasons to use `[]` instead of `$`. For instance, we can 
provide two arguments to `[]` in order to select a row and a column, instead of 
just a row:

```{r}
# Select row 15 from the sepal length column:
iris[[15, "Sepal.Length"]]
```

<br>

--

We can also provide vectors as arguments to `[]` to return multiple rows or 
columns:
```{r}
# Select rows 1:6 from the sepal length and species columns
# Note that 1:6 is a shorthand for c(1, 2, 3, 4) -- it generates a 
# sequence between any two integers
iris[1:4, c("Sepal.Length", "Species")]
```

--

<br>

When working with data frames, the order is always `[row, column]`

---

There's one more way to store data in R, called a _list_:

```{r}
list(x = c("one", "two"),
           y = c(9, 8))
```

<br>

Lists are a special type of vector, which function a lot like data frames. 

---

Similarly to a data frame, lists can store vectors of different data types. 
Uniquely, however, lists are able to store vectors of different _lengths_, 
too:

```{r}
list(x = c("one", "two"),
           y = c(9, 8, 7, 6, 5))
```

<br>

This makes lists very useful for a lot of programming purposes, but they don't 
really lend themselves to data analysis -- its hard to have tidy datasets when 
your vectors can be any length and aren't stored in a nice tabular format.

---

That said, some R functions return list objects, so we should go over the basics
of how you work with lists.

<br>

Let's say we have some list called `our_list`:

```{r}
our_list <- list(x = c("one", "two"),
           y = c(9, 8, 7, 6, 5))

our_list
```

<br>

(See that `<-`? That's the `assignment operator` -- we can use it to store 
anything we create in R as an _object_. We can then just use the _name_ of that
object to get our original _value_ back.)

---

We can then subset using the same tricks we use for dataframes, with a few 
small differences.

<br>

First, using `[]` to subset will return a list, instead of a dataframe:

```{r}
our_list[1]
```

--

Second, we can't use pull specific values from a list using `[[]]` or 
`[row, number]` format. 

<br>

Instead, we need to use `[[]]` or `$` to extract a vector, then subset that 
vector again to get specific values:

```{r}
our_list[[2]][3:5]
```

<br>

Again, we won't be using lists too much in this early section of the course, so 
don't worry if they seem confusing right now!

---

# Things We've Learned:

### 1: All data in R is one of several types of data -- and a vector can only be one type of data:

```{r}
class(1)

class("hello world")

class(TRUE)

class(c(1, "hello world"))
```

---

### 2: We can use _logical operators_ to determine if a statement is true or false:

```{r}
4 > 5

10 <= 10

5 == 5

5 != 5

TRUE == 1

FALSE == 0
```

---

### 3: Vectors can only store one type of data, but dataframes can store multiple vectors:

```{r}
data.frame(x = c("one", "two"),
           y = c(9, 8))
```

---

### 4: R provides several methods to _subset_ our dataframes into smaller tables:

```{r}
iris[48:52, "Sepal.Width"]

iris[[1, 2]]

head(iris$Species)
```
